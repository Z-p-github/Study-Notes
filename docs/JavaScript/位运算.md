今天我们来看看什么是二进制以及什么是位运算

## 二进制

- 计算机使用二进制来存储数字
- 为了简化运算，二进制数都是用一个字节(8 个二进制位)来简化说明

### 真值

- 8 位二进制数能表示的真值范围是[-2^8,+2^8]

真值就是带符号位的机器数对应的真正数值，个人理解就是用正负号来代替符号位来表示机器数
例如：

```js
+000000001; //+1
-100000001; //-1
```

### 原码

- 由于计算机只能存储 0 和 1，不能存储正负
- 所以用 8 个二进制位的最高位来表示符号，0 表示正，1 表示负，用后七位表示真值的绝对值
- 这种表示方法称为原码表示法，简称原码
- 由于 10000000 的意思是-0，这个就没有意义，所以这个数子用来表示-128
- 由于最高位用来表示符号位了，现在能表示的范围是[-2^7,+2^7-1]，即[-128,+127]

```js
0 0000001; //+1
1 0000001; //-1
```

### 反码

- 反码是另外一种表示数字的方法
- 其规则就是正数的反码和他的原码一样
- 负数的反码是将其原码的符号位不变，其余各位按位取反
- 反码的表示范围是[-2^7,+2^7-1]，即[-128,+127]

```js
0 0000001; //+1
1 1111110; //-1
```

### 补码

- 补码是为了简化运算，将减法变为加法而发明的数字表示法
- 其规则是正数的补码和原码一样，负数的补码是反码末尾加 1
- 8 位补码表示的范围是 [-2^7,+2^7-1]，即[-128,+127]
- 快速计算负数补码的规则是，由其原码低位向高位找到第一个 1，1 和其低位不变，1 前面的高位按位取反即可

```js
0 0000001; //+1
1 1111111; //-1
```

### 为何需要使用反码和补码

使用原码进行计算的时候，对于人而言能够很轻易的辨别出符号位，然后直接对其他位数值进行计算。然而对于计算机的设计而言辨别出符号位就是一项非常复杂的工程，所以设计的时候就考虑让符号位直接参与计算，这样设计计算机就十分简单了。 对于加法而言符号位对于计算并没有影响，对于减法而言则考虑通过加上负数来转换为加法的方式进行计算。 如果通过原码来直接进行减法计算：

```js
3 - 2
= 3 + (-2)
= 0000 0011(原) + 1000 0010(原)
= 1000 0101
= -5
```

结果显而易见，如果通过原码来直接让符号位参与运算的话是不正确的，所以为了解决减法的问题引入了反码的概念。如果通过反码来进行减法计算：

```js
3 - 2
 = 3 + (-2)
 = 0000 0011(原) + 1000 0010(原)
 = 0000 0011(反) + 1111 1101(反)
 = 1 0000 0000(反) -- 最高位产生进位，结果+1
 = 0000 0001(反)
 = 0000 0001(原)
 = 1
```

结果正确，从上面例子看来如果通过反码进行减法运算的话是没有问题的，那为什么又需要补码呢，我们一起来看下面这个特殊的例子：

```js
2 - 2
= 2 + (-2)
= 0000 0010(原) + 1000 0010(原)
= 0000 0010(反) + 1111 1101(反)
= 1111 1111(反)
= 1000 0000(原)
= -0

0 + 0
= 0000 0000(原) + 0000 0000(原)
= 0000 0000(反) + 0000 0000(反)
= 0000 0000(反)
= 0000 0000(原)
= 0
```

由于对于 0 这个数字而言，正负号没有任何意义，但是经过计算却有可能出现[0000 0000]和[1000 0000]这两种不同的原码表示同一个数字 0，这显然是不合理的，所以此时就引入了补码的概念。 如果通过补码来进行上述例子的计算：

```js
2 - 2
= 2 + (-2)
= 0000 0010(原) + 1000 0010(原)
= 0000 0010(反) + 1111 1101(反)
= 0000 0010(补) + 1111 1110(补)
= 1 0000 0000(补) -- 最高位产生进位，进位舍弃
= 0000 0000(补)
= 0000 0000(反)
= 0000 0000(原)
= 0

  0 + 0
= 0000 0000(原) + 0000 0000(原)
= 0000 0000(反) + 0000 0000(反)
= 0000 0000(补) + 0000 0000(补)
= 0000 0000(反)
= 0000 0000(原)
= 0
```

由上述例子可以看出，补码完美的解决了 0 的符号问题以及 0 有两个不同原码表示的问题。而且[10000 0000]也可以用来表示-128：

```js
-1 - 127
= -1 + (-127)
= 1000 0001(原) + 1111 1111(原)
= 1111 1110(反) + 1000 0000(反)
= 1111 1111(补) + 1000 0001(补)
= 1 1000 0000(补) --最高位产生进位，进位舍弃
= 1000 0000(补)
```

-1 - 127 的结果为-128，上面例子中-1 和-127 补码相加后得出的补码也是-128。但是这个 1000 0000(补)实际上对应的是之前的-0，所以这个补码是没有反码和原码的。 综上可以看出使用补码的话不仅 0 的符号问题和多原码问题可以解决，还可以多表示一个最小数。因此对于 1 字节而言，原码和反码的范围是[-127, 127]，而补码的范围是[-128, 127]，也可以解释 java 中 int 的范围是[-2, 2-1]。

## 位运算符

在位运算的过程中，会涉及到很多位运算符的使用，下面我们来看看这些运算符代表的是什么意思

- 按位与(&)
  > 使用方式 x & y 每一个比特位都为 1 时，结果为 1，否则为 0
- 按位或(｜)
  > 使用方式 x ｜ y 每一个比特位都为 0 时，结果为 0，否则为 1
- 按位异或(^)
  > 使用方式 x^y 每一个比特位相同结果为 0，不相同结果为 1
- 按位非(~)
  > 使用方式 ~x 对每一个比特位取反，0 变成 1，1 变成 0
- 左移(<<)
  > 使用方式 x << y 将 x 的每一个比特为左移 y 位，右侧补充 0
- 有符号右移(>>)
  > 使用方式 x >> y 将 x 的每一个比特为向右移动 y 个位，右侧移除位丢弃，左侧填充为最高位
- 无符号右移(>>>)
  > 使用方式 x >>> y 将 x 的每一个比特为向右移动 y 个位，右侧移除位丢弃，左侧填充为 0

下面我们来具体的来演示一下这几种运算符的作用和功能：

```js
//我们申明两个二进制数，0b开头，表示这是一个二进制的数
let a = 0b100; //4
let b = 0b011; //3

//按位与(&)
let d = a & b; // 0
console.log(d.toString(2)); //0b000

//按位或(｜)
let e = a | b; // 7
console.log(e.toString(2)); //0b111

//按位异或(^)
let f = a ^ b; // 7
console.log(f.toString(2)); //0b111

//按位非(~),按位非运算时，任何数字x的运算结果都是  -(x+1)，例如，~4 的结果是 -5
let g = ~b; // -4
console.log(g.toString(2)); //0b100

//左移(<<) , b之前是011，左移动了两位之后的二进制是 1100，对应十进制 12
let h = b << 2; // 12
console.log(h.toString(2)); //0b1100

//有符号右移(>>), b之前是011，右移动了两位之后的二进制是 000，对应十进制 0
let j = b >> 2; // 0
console.log(j.toString(2)); //0b0000

//无符号右移(>>>), b之前是011，右移动了两位之后的二进制是 000，对应十进制 0
let k = b >>> 2; // 0
console.log(k.toString(2)); //0b0000
```

### 无符号和有符号右移的区别

我们知道，计算机中以二进制存储数字，二进制中最左边的第一位，叫符号位，所以这就很明显了，右移 2 位后，最左边缺少 2 位数字，那就应该填充数字，那填充什么呢？

符号位是什么，我就填什么，所以 -4 >> 2 中最左边 2 位和符号位一样，都是 1。

因此所说的 有符号、无符号 看的就是二进制的符号位， 无符号:就不管符号位，右移只填充 0；有符号，就是符号位是啥，我就填充啥

负数进行无符号右移会变成正数，整数和有符号右移没有区别
